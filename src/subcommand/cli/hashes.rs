use ckb_app_config::{cli, CKBAppConfig, ExitCode};
use ckb_chain_spec::ChainSpec;
use ckb_core::script::Script;
use ckb_resource::{Resource, ResourceLocator, CKB_CONFIG_FILE_NAME};
use clap::ArgMatches;
use numext_fixed_hash::H256;
use serde_derive::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::convert::{TryFrom, TryInto};
use std::path::PathBuf;

#[derive(Clone, Debug, Serialize, Deserialize)]
struct SystemCellHashes {
    pub path: String,
    pub code_hash: H256,
    pub script_hash: H256,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct SpecHashes {
    pub genesis: H256,
    pub cellbase: H256,
    pub system_cells: Vec<SystemCellHashes>,
}

impl TryFrom<ChainSpec> for SpecHashes {
    type Error = ExitCode;

    fn try_from(mut spec: ChainSpec) -> Result<Self, Self::Error> {
        let hash_option = spec.genesis.hash.take();
        let consensus = spec.build_consensus().map_err(to_config_error)?;
        if let Some(hash) = hash_option {
            if hash != *consensus.genesis_hash() {
                eprintln!(
                    "Genesis hash unmatched in {} chainspec config file: in file {:#x}, actual {:#x}",
                    spec.name,
                    hash,
                    consensus.genesis_hash()
                );
            }
        }

        let block = consensus.genesis_block();
        let cellbase = &block.transactions()[0];

        // Zip name with the transaction outputs. System cells start from 1 in the genesis cellbase outputs.
        let cells_hashes = spec
            .genesis
            .system_cells
            .resources
            .iter()
            .zip(cellbase.outputs().iter().skip(1))
            .map(|(resource, output)| {
                let code_hash = output.data_hash();
                let script_hash = Script::new(vec![], code_hash.to_owned()).hash();
                SystemCellHashes {
                    path: resource.to_string(),
                    code_hash,
                    script_hash,
                }
            })
            .collect();

        Ok(SpecHashes {
            genesis: consensus.genesis_hash().to_owned(),
            cellbase: cellbase.hash().to_owned(),
            system_cells: cells_hashes,
        })
    }
}

pub fn hashes<'m>(locator: ResourceLocator, matches: &ArgMatches<'m>) -> Result<(), ExitCode> {
    let mut specs = BTreeMap::<String, SpecHashes>::new();

    if matches.is_present(cli::ARG_BUNDLED) {
        println!("# Generated by: ckb cli hashes -b");
        let resource = Resource::Bundled(CKB_CONFIG_FILE_NAME.to_string());
        let dev =
            ChainSpec::resolve_relative_to(&locator, PathBuf::from("specs/dev.toml"), &resource)
                .map_err(to_config_error)?;
        specs.insert(dev.name.clone(), dev.try_into()?);

        let testnet = ChainSpec::resolve_relative_to(
            &locator,
            PathBuf::from("specs/testnet.toml"),
            &resource,
        )
        .map_err(to_config_error)?;
        specs.insert(testnet.name.clone(), testnet.try_into()?);
    } else {
        println!("# Generated by: ckb cli hashes");
        let resource = locator.ckb();
        let config: CKBAppConfig = toml::from_slice(&resource.get()?)?;
        let chain_spec = ChainSpec::resolve_relative_to(&locator, config.chain.spec, &resource)
            .map_err(to_config_error)?;
        specs.insert(chain_spec.name.clone(), chain_spec.try_into()?);
    }

    print!("{}", toml::to_string(&specs).unwrap());

    Ok(())
}

fn to_config_error(err: Box<dyn std::error::Error>) -> ExitCode {
    eprintln!("{:?}", err);
    ExitCode::Config
}
