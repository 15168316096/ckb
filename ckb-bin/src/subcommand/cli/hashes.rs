use ckb_app_config::{cli, CKBAppConfig, ExitCode};
use ckb_chain_spec::ChainSpec;
use ckb_resource::{Resource, AVAILABLE_SPECS};
use ckb_types::{prelude::*, H256};
use clap::ArgMatches;
use serde_derive::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::convert::{TryFrom, TryInto};
use std::path::PathBuf;

#[derive(Clone, Debug, Serialize, Deserialize)]
struct SystemCell {
    pub path: String,
    pub index: usize,
    pub code_hash: H256,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct SpecHashes {
    pub genesis: H256,
    pub cellbase: H256,
    pub system_cells: Vec<SystemCell>,
}

impl TryFrom<ChainSpec> for SpecHashes {
    type Error = ExitCode;

    fn try_from(mut spec: ChainSpec) -> Result<Self, Self::Error> {
        let hash_option = spec.genesis.hash.take();
        let consensus = spec.build_consensus().map_err(to_config_error)?;
        if let Some(hash) = hash_option {
            if hash != *consensus.genesis_hash() {
                eprintln!(
                    "Genesis hash unmatched in {} chainspec config file:\n\
                     in file {:#x},\n\
                     actual {:#x}",
                    spec.name,
                    hash,
                    consensus.genesis_hash()
                );
            }
        }

        let block = consensus.genesis_block();
        let cellbase = &block.transactions()[0];

        // Zip name with the transaction outputs. System cells start from 1 in the genesis cellbase outputs.
        let cells_hashes = spec
            .genesis
            .system_cells
            .files
            .iter()
            .zip(cellbase.outputs().into_iter().skip(1))
            .enumerate()
            .map(|(index_minus_one, (resource, output))| {
                let code_hash: H256 = output.data_hash().unpack();
                SystemCell {
                    path: resource.to_string(),
                    index: index_minus_one + 1,
                    code_hash,
                }
            })
            .collect();

        Ok(SpecHashes {
            genesis: consensus.genesis_hash().to_owned(),
            cellbase: cellbase.hash().unpack(),
            system_cells: cells_hashes,
        })
    }
}

pub fn hashes<'m>(root_dir: PathBuf, matches: &ArgMatches<'m>) -> Result<(), ExitCode> {
    let mut specs = BTreeMap::<String, SpecHashes>::new();

    if matches.is_present(cli::ARG_BUNDLED) {
        println!("# Generated by: ckb cli hashes -b");
        for env in AVAILABLE_SPECS {
            let spec = ChainSpec::load_from(&Resource::bundled(format!("specs/{}.toml", env)))
                .map_err(to_config_error)?;
            specs.insert(spec.name.clone(), spec.try_into()?);
        }
    } else {
        println!("# Generated by: ckb cli hashes");
        let mut resource = Resource::ckb_config(&root_dir);
        if !resource.exists() {
            resource = Resource::bundled_ckb_config();
        }

        let mut config: CKBAppConfig = toml::from_slice(&resource.get()?)?;
        config.chain.spec.absolutize(&root_dir);
        let chain_spec = ChainSpec::load_from(&config.chain.spec).map_err(to_config_error)?;
        specs.insert(chain_spec.name.clone(), chain_spec.try_into()?);
    }

    print!("{}", toml::to_string(&specs).unwrap());

    Ok(())
}

fn to_config_error(err: Box<dyn std::error::Error>) -> ExitCode {
    eprintln!("{:?}", err);
    ExitCode::Config
}
